\documentclass[11pt]{article}
\usepackage[margin=1.6in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{amsmath, amsthm}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage[frenchb]{babel}
\usepackage{color}
\usepackage{listings}
\lstset{
  %frame=tb,
  language=Bash,
  aboveskip=2mm,
  belowskip=2mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\footnotesize\color{gray},
  %keywordstyle=\color{blue},
  %commentstyle=\color{dkgreen},
  %stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
         
% Pour XeTeX
\XeTeXdefaultencoding utf-8
\usepackage{fontspec}

\newenvironment{absolutelynopagebreak}
  {\par\nobreak\vfil\penalty0\vfilneg
   \vtop\bgroup}
  {\par\xdef\tpd{\the\prevdepth}\egroup
   \prevdepth=\tpd}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\tolerance=1000
\setcounter{secnumdepth}{2}
\author{Borne, Duquennoy, Duverney, Isnel}
\date{}
\title{Nachos Pré-rapport}

\begin{document}
\maketitle
\section{Consignes}
Un rapport de 8 à 12 pages maximum dont l'objectif est de nous convaincre d'acheter votre nachos. Ce rapport sera structuré en 5 parties :
une (courte) partie présentant rapidement les fonctionnalités intéressante/importante de votre noyau (ce qui vous démarque de vos concurrents, ce qu'on peut faire avec votre logiciel, ...).

Une partie "spécifications" listant ce qui est disponible pour les programmes utilisateurs.
Il faut mettre ici le genre d'information que vous trouvez dans les pages man.
On doit donc trouver tous les appels systèmes implémentés avec leur prototype, la description des arguments,
la description du fonctionnement (fonctionnalités utilisateurs, pas implémentation) de l'appel système,
de la valeur de retour éventuelle, la signalisation des erreurs, ...
Si vous avez également une bibliothèque utilisateur, vous devez décrire ses fonctions de la même manière que les appels systèmes.

Une partie "tests utilisateurs" décrivant les programmes de test que vous avez réalisés, ce qu'ils montrent, ...

Une partie "implémentation" qui explique les points importants de votre implémentation. C'est donc la seule partie qui parle du détail du code que vous avez écrit. Expliquez vos choix d'implémentation.
une partie plus "scolaire" où vous décrivez l'organisation de votre travail (planning, ...), commentaires constructifs sur le déroulement du projet, ...

Les 3 premières parties s'adressent à un utilisateur de votre système. La 4ième partie s'adresse à un développeur qui voudrait continuer à développer votre système. Si vous avez bien travaillé sur les spécifications comme demandé, ces parties techniques seront faciles à écrire.

\section{Fonctionnalités}

Environnement utilisateur multi-processus avec espaces d'adressages et memoire virtuelle.
Processus utilisateur multi-threadés avec primitives de synchronisation (Mutex, Semaphores, variables-conditions).
Gestion des entrées-sorties (GetInt, PutInt, GetChar, PutChar, GetString, Putstring).
Système de fichier type FAT.
Protocole réseau avec envoi fiable de données.

\section{Spécifications}
\subsection{Entrées-Sorties}

\subsubsection{\texttt{void PutChar(char c)}}
\begin{itemize}
\item[-] Sémantique: Écrit le caractère c sur la sortie standard.
\end{itemize}

\subsubsection{\texttt{void PutString(const char *s);}}
\begin{itemize}
\item[-] Sémantique: Écrit la chaîne de caractères lue à l'adresse \texttt{s}.
\end{itemize}

\subsubsection{\texttt{char GetChar()}}
\begin{itemize}
\item[-] Sémantique: Lit un caractère depuis l'entrée standard et retourne le caractère lu.
\end{itemize}

\subsubsection{\texttt{void GetString(char *s, int n)}}
\begin{itemize}
\item[-] Sémantique:
  Lit une chaîne de caractères de longueur maximale égale à \texttt{n} depuis l'entrée standard et
  l'écrit à l'adresse de \texttt{s}.
\item[-] Pré-Conditions: L'adresse \texttt{s} est valide.
\end{itemize}

\subsubsection{void PutInt(int n)}
\begin{itemize}
\item[-] Sémantique: Écrit l'entier \texttt{n} sur la sortie standard.
\end{itemize}

\subsubsection{\texttt{void GetInt(int *n)}}
\begin{itemize}
\item[-] Sémantique: Lit un entier depuis l'entrée standard et l'écrit à l'adresse \texttt{n}.
\item[-] Pré-Conditions: L'adresse \texttt{n} est valide.
\end{itemize}

\subsection{Processus et Threads}

\subsubsection{\texttt{int ForkExec(char * fileName)}}
 \begin{itemize}
 \item[-] Sémantique: Crée un nouveau processus qui éxécute le fichier donné en paramètre
 \end{itemize}

\subsubsection{\texttt{int UserThreadCreate(void f(void* arg), void* arg)}}
\begin{itemize}
\item[-] Sémantique: Crée un nouveau thread utilisateur qui exécute la fonction \texttt{f(arg)}.
\item[-] Pré-Conditions: Le système doit disposer d'une quantité de mémoire suffisante pour allouer la
  pile du thread à créer. 
\item[-] Valeur de retour: retourne l'identficateur du thread crée, $-1$ si une erreur s'est produite lors de
  la création.
\end{itemize}

\subsubsection{\texttt{void UserThreadExit()}}
\begin{itemize}
\item[-] Sémantique: Termine le thread courant.
\end{itemize}

\subsubsection{\texttt{int UserThreadJoin(int tid)}}
\begin{itemize}
\item[-] Sémantique: Attends la terminaison du Thread $tid$, renvoie $-1$
 si le thread est déjà terminé, $0$ sinon.
\end{itemize}

\subsection{Synchronisation}
\subsubsection{\texttt{int MutexCreate()}}
\begin{itemize}
\item[-]Sémantique: Crée un mutex et retourne un numéro d'identifiant
\end{itemize}

\subsubsection{\texttt{void MutexLock(int mutexId)}}
\begin{itemize}
\item[-]Sémantique: Acquiert le vérrou dont l'identifiant est mutexId
\end{itemize}

\subsubsection{\texttt{void MutexUnlock(int mutexId)}}
\begin{itemize}
\item[-]Sémantique: Relache le vérrou dont l'identifiant est mutexId
\end{itemize}

\subsubsection{\texttt{void MutexDestroy(int mutexId)}}
\begin{itemize}
\item[-]Sémantique: Détruit le vérrou dont l'identifiant est mutexId
\end{itemize}

\subsubsection{\texttt{Sem\_t SemCreate(int initialValue)}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}

\subsubsection{\texttt{Sem\_t SemCreate(int initialValue)}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}

\subsubsection{\texttt{void SemPost(Sem\_t semaphore)}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}

\subsubsection{\texttt{void SemDestroy(Sem\_t semaphore)}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}

\subsubsection{\texttt{int CondCreate()}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}

\subsubsection{\texttt{void CondWait(Cond\_t condId, Mutex\_t mutedId)}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}

\subsubsection{\texttt{void CondSignal(Cond\_t condId)}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}

\subsubsection{\texttt{void CondBroadCast(Cond\_t condId)}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}

\subsubsection{\texttt{void CondDestroy(Cond\_t condId)}}
\begin{itemize}
\item[-]Sémantique: 
\end{itemize}




\section{Implémentation}
\subsection{Passage de paramètres}
Pour les fonctions ayant moins de quatre arguments, on suppose que les paramètres sont dans les registres 4 à 7.
Aussi, la première chose à faire dans le code d' une fonction est de récupérer et sauvegarde ces registres dans des variables locales à la fonction.

\subsection{Processus et Threads}
On identifie un Processus à un espace d'adressage, i.e. un objet \texttt{AddrSpace}.

Chaque objet \texttt{Thread} possède:
\begin{itemize}
\item[-] Une référence vers son espace d'adressage \texttt{space}.
\item[-] Un identifiant unique sur l'ensemble du sytème \texttt{tid} de type \texttt{int} (compteur du nombre
  total de threads crées).
\end{itemize}

\subsubsection{Piles des threads}
Afin d'acceuillir les piles de nouveaux threads on divise un espace d'adressage \texttt{addrSpace}
en blocs de pages, de taille \texttt{NumPagesPerStack}.
Une bitmap \texttt{stackBitmap} mémorise l'état courant des emplacement libres pour les piles.

\subsubsection{Terminaison automatique des threads}
Dans \texttt{Start.S} lors de l'appel système \texttt{UserThreadCreate}, on place dans le registre 6 de la machine mips l'adresse de l'instruction \texttt{UserThreadExit}.
Lors de la création du nouveau thread au niveau noyau avec \texttt{do\_UserThreadcreate} on réccupère
cette adresse depuis \texttt{r6} et au moment de \texttt{Fork}, avant de brancher la machine \texttt{MIPS} sur
le nouveau thread utilisateur on place cette adresse dans le registre \texttt{RetAddrReg}.

\subsubsection{Thread Join}
Au sein d'un processus, un thread peut utiliser la fonction join pour attendre la terminaison d'un autre thread.
On maintient dans chaque \texttt{addressSpace} une structure \texttt{joinMap}.
La Map associe à un \texttt{tid} une liste de Threads.
Lorsqu'un Thread $t1$ fait un \texttt{join} sur un Thread $t2$ on ajoute dans \texttt{joinMap}
l'association $(t2, [t1])$. Cette association signifie que $t2$ est attendu par $t1$.
Le Thread $t1$ se met allors en sommeil avec \texttt{Sleep()}. 
Si $t3$ fait un join sur $t2$ la \texttt{joinMap} est dans l'état $(t2, [t1,t3])$ et $t3$ est mis en sommeil.
Lorsque $t2$ termine son execution il place $t1$ et $t3$ dans la readylist du scheduler.

On maintient une liste \texttt{threadList} des threads actifs dans un espace d'adressage.
Un thread $t1$ ne peut faire un join que vers un thread $t2$ actif.
Un thread peut être attendu par deux threads différents.

\subsubsection{Fermeture d'un processus}



\section{Tests}

\subsection{Entrées-Sorties}
\begin{itemize}
\item[-] \texttt{Putchar\_0}: Écriture du caractère \texttt{'a'} sur la sortie standard.
\item[-] \texttt{Putchar\_1}: Écriture du caractère \texttt{'a'} et \texttt{'b'} sur la sortie standard.
\item[-] \texttt{Putchar\_2}: Écriture de multiples caractères sur la sortie standard.
\item[-] \texttt{PutInt\_0}: Écriture de l' entier \texttt{10} sur la sortie standard.
\item[-] \texttt{PutInt\_1}: Écriture de l'entier \texttt{0} et de l'entier \texttt{1} sur la sortie standard.
\item[-] \texttt{GetInt\_0}: Lecture d'un entier depuis l'entrée standard.
\item[-] \texttt{GetInt\_PutInt\_0}:
  Lecture d'un entier depuis l'entrée standard.
  Écriture de cet entier sur la sortie standard.
\item[-] \texttt{GetString\_0}: Lecture d'une chaîne de moins de \texttt{20} caractères depuis l'entrée standard, affichage de cette chaîne sur la sortie standard.
\item[-] \texttt{PutString\_0}: Affichage de la chaîne de caractère \texttt{"ABCDEFGHIJklmnopqrstuvwxyz"}.
\item[-] \texttt{PutString\_1}: Affichage de la chaîne \texttt{"ABCDEFGH"} et \texttt{"ijklmnopqrstuvwxyz"}.
\item[-] \texttt{PutString\_2}:   Affichage d'une chaîne de taille supérieure à la
  constante \texttt{MAX\_STRING\_SIZE(=100)} définie dans \texttt{system.h}.
\end{itemize}

\subsection{UserThreads}
Afin de vérifier le bon fonctionnement des structures de synchronisation des fonctions d'entrée-sorties,
les programmes de tests ont été lancés avec et sans l'option \texttt{-rs} qui permet de rendre aléatoire le comportement de l'ordonnanceur.

\begin{itemize}
\item[-] \texttt{UserThreadcreate\_0}: Lancement de \texttt{N} threads utilisateurs qui affichent chacun un entier passé en paramètre lors de leur
  création.
\item[-] \texttt{Userthreadcreate\_1}: Lancement de deux threads utilisateur. Le premier affiche \texttt{"X"} puis le caractère \texttt{'a'} passé en paramètre.
  Le second afficher \texttt{"Y"} puis le caractère \texttt{'b'} passé en paramètre.
\item[-] \texttt{Userthreadcreate\_2}: Lancement d'un nombre de thread trop important pour l'espace mémoire.
  Le programme affiche l'identifiant des threads crées.
\item[-] \texttt{MultiThreadGetString\_0}: Lance plusieurs threads exécutant la commande \texttt{GetString()}.
\end{itemize}

\subsection{Entrées-Sorties Multithread}
 Avec les tests suivants, on vérifie le bon fonctionnement des structures de synchronisation par l'utilisation
  concurrente de synchconsole.
\begin{itemize}
\item[-] \texttt{MultithreadGetChar\_0}: Création de plusieurs threads exécutant \texttt{GetChar}
  puis \texttt{Putchar}.
  Remarque:
  A l'exécution, lorsqu'un thread s'exécute il se bloque sur l'instruction \texttt{GetChar()} et attends une
  entrée utilisateur. L'utilisateur entre un caractère \texttt{'c'} et \texttt{'$\backslash$n'} pour terminer son entrée.
  Suite à l'appel de \texttt{GetChar()}, le caractère \texttt{'$\backslash$n'} est toujours
  présent dans l'entrée standard. Aussi, le thread suivant exécutant \texttt{GetChar()} récupère et
  affiche \texttt{'$\backslash$n'}.
\item[-] \texttt{MultithreadGetInt\_0}: Création de plusieurs threads exécutant \texttt{GetInt}
  puis \texttt{PutInt} pour afficher l'entier saisi.
\item[-] \texttt{MultithreadGetString\_0}: Création de plusieurs threads exécutant
  \texttt{getString} puis \texttt{PutString}.
\item[-] \texttt{MultithreadPutChar\_0}: Création de plusieurs threads exécutant \texttt{getString}
  puis \texttt{PutString}.
\item[-] \texttt{MultithreadPutString\_0}: Création de plusieurs threads exécutant \texttt{PutString}.
\end{itemize}






\section{Organisation}
Pour les premières étapes nous avons travaillé sur un ordinateur commun.
Cette approche basée sur une communication constante et une implication de tous les membres du groupe
nous a permis d'échanger de manière constructive sur les choix d'implémentation, de s'assurer que
nous avions tous une compréhension et vision homogène du fonctionnement de notre code. Nous
avons adopté un point de vue critique vis à vis du code produit,
n'hésitant pas à discuter en détail des points qui ne nous semblaient pas clairs
avant pendant et après l'écriture de nos fonctions. Nous n'avons éprouvé aucune difficultés de communication
tant sur les aspects techniques que dans nos rapport au travail en général.

\end{document}

