\documentclass[11pt]{article}
\usepackage[margin=1.6in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{amsmath, amsthm}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage[frenchb]{babel}
\usepackage{color}
\usepackage{listings}
\lstset{
  %frame=tb,
  language=Bash,
  aboveskip=2mm,
  belowskip=2mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\footnotesize\color{gray},
  %keywordstyle=\color{blue},
  %commentstyle=\color{dkgreen},
  %stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
         
% Pour XeTeX
\XeTeXdefaultencoding utf-8
\usepackage{fontspec}

\newenvironment{absolutelynopagebreak}
  {\par\nobreak\vfil\penalty0\vfilneg
   \vtop\bgroup}
  {\par\xdef\tpd{\the\prevdepth}\egroup
   \prevdepth=\tpd}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\tolerance=1000
\setcounter{secnumdepth}{2}
\author{Borne, Duquennoy, Duverney, Isnel}
\date{}
\title{Nachos Pré-rapport}

\begin{document}
\maketitle



\section{Fonctionnalités}
Environnement utilisateur multi-processus avec espaces d'adressages séparés et virtualisation memoire.
Processus utilisateur multi-threadés avec primitives de synchronisation (Mutex, Semaphores, variables-conditions).
Gestion des entrées-sorties (GetInt, PutInt, GetChar, PutChar, GetString, Putstring).
Système de fichier inspiré ext4.
Protocole réseau sans connection avec envoi fiable de données.
Utilisation interractive via un Shell (exec, cd, ls, mkdir, open ...).
\section{Spécifications}
\subsection{Entrées-Sorties}

\subsubsection{\texttt{void PutChar(char c)}}
\begin{itemize}
\item[-] Sémantique: Écrit le caractère \texttt{c} sur la sortie standard.
\end{itemize}

\subsubsection{\texttt{void PutString(const char *s);}}
\begin{itemize}
\item[-] Sémantique: Écrit la chaîne de caractères lue à l'adresse \texttt{s}.
\end{itemize}

\subsubsection{\texttt{char GetChar()}}
\begin{itemize}
\item[-] Sémantique: Lit un caractère depuis l'entrée standard et retourne le caractère lu.
\end{itemize}

\subsubsection{\texttt{void GetString(char *s, int n)}}
\begin{itemize}
\item[-] Sémantique:
  Lit une chaîne de caractères de longueur maximale égale à \texttt{n} depuis l'entrée standard et
  l'écrit à l'adresse \texttt{s}.
\item[-] Pré-Conditions: L'adresse \texttt{s} est valide (espace suffisant).
\end{itemize}

\subsubsection{void PutInt(int n)}
\begin{itemize}
\item[-] Sémantique: Écrit l'entier \texttt{n} sur la sortie standard.
\end{itemize}

\subsubsection{\texttt{void GetInt(int *n)}}
\begin{itemize}
\item[-] Sémantique: Lit un entier depuis l'entrée standard et l'écrit à l'adresse \texttt{n}.
\item[-] Pré-Conditions: L'adresse \texttt{n} est valide.
\end{itemize}

\subsection{Processus et Threads}

\subsubsection{\texttt{int ForkExec(char * fileName)}}
 \begin{itemize}
 \item[-] Sémantique: Crée un nouveau processus qui exécute le fichier donné en paramètre
 \end{itemize}

\subsubsection{\texttt{int UserThreadCreate(void f(void* arg), void* arg)}}
\begin{itemize}
\item[-] Sémantique: Crée un nouveau thread utilisateur qui exécute la fonction \texttt{f(arg)}.
\item[-] Pré-Conditions: Le système doit disposer d'une quantité de mémoire suffisante pour allouer la
  pile du thread à créer. 
\item[-] Valeur de retour: retourne l'identficateur du thread crée, $-1$ si une erreur s'est produite lors de
  la création.
\end{itemize}

\subsubsection{\texttt{void UserThreadExit()}}
\begin{itemize}
\item[-] Sémantique: Termine l'exécution du thread courant.
\end{itemize}

\subsubsection{\texttt{int UserThreadJoin(int tid)}}
\begin{itemize}
\item[-] Sémantique: Attends la terminaison du Thread $tid$, renvoie $-1$
  si le thread est déjà terminé, $0$ sinon.
\item[-] Pré-Conditions: Le thread courant n'a pas déjà fait join(tid). 
\end{itemize}

\subsection{Synchronisation}
\subsubsection{\texttt{Mutex\_t MutexCreate()}}
\begin{itemize}
\item[-]Sémantique: Initialise une variable de type \texttt{Mutex\_t}.
\end{itemize}

\subsubsection{\texttt{void MutexLock(Mutex\_t mutex)}}
\begin{itemize}
\item[-]Sémantique: Acquiert le vérrou \texttt{mutex}. Si le mutex est déverrouillé, il devient verrouillé
  et possédé par le thread appelant. Si le mutex est déjà verrouillé par un autre thread,
  le thread appelant est suspendu jusqu'à ce que le mutex soit déverrouillé.
\end{itemize}

\subsubsection{\texttt{void MutexUnlock(Mutex\_t mutex)}}
\begin{itemize}
\item[-]Sémantique: Relache le verrou \texttt{mutex}.
\item[-]Pré-Condition: Le mutex est Verrouillé.
\end{itemize}

\subsubsection{\texttt{MutexDestroy(Mutex\_t mutex)}}
\begin{itemize}
\item[-]Sémantique: Détruit le verrou \texttt{mutex}.
\item[-]Pré-Condition: Le verrou est relâché. Détruire un verrou non relâché mène à un comportement
  non déterminé.
\end{itemize}

\subsubsection{\texttt{Sem\_t SemCreate(int initialValue)}}
\begin{itemize}
\item[-]Sémantique: Initialise un variable de type \texttt{Sem\_t}. 
\end{itemize}

\subsubsection{\texttt{Sem\_t SemWait(int semaphore)}}
\begin{itemize}
\item[-]Sémantique: Le thread appelant attends que la sémaphore ait une valeur $>0$ et la décrémente. 
\end{itemize}

\subsubsection{\texttt{void SemPost(Sem\_t semaphore)}}
\begin{itemize}
\item[-]Sémantique: Incrémente la valeur de la sémaphore, réveille un thread en attente de cette sémaphore
  si besoin.
\end{itemize}

\subsubsection{\texttt{void SemDestroy(Sem\_t semaphore)}}
\begin{itemize}
\item[-]Sémantique: Libère les ressources associées à la sémaphore. 
\end{itemize}

\subsubsection{\texttt{Cond\_t CondCreate()}}
\begin{itemize}
\item[-]Sémantique: Initialise une variable de type Cond\_t.
\end{itemize}

\subsubsection{\texttt{void CondWait(Cond\_t condId, Mutex\_t mutedId)}}
\begin{itemize}
\item[-]Sémantique: Met le thread appelant en sommeil dans la file d'attente associée à condId,
  relâche le verrou mutexId.
\item[-]Pré-Condition: mutexId est verrouillé.
\end{itemize}

\subsubsection{\texttt{void CondSignal(Cond\_t condId)}}
\begin{itemize}
\item[-]Sémantique: Réveille un thread en sommeil dans la file d'attente associée à la variable
  condition condId. Si aucun thread n'est présent dans la liste, le signal est perdu.
\end{itemize}

\subsubsection{\texttt{void CondBroadCast(Cond\_t condId)}}
\begin{itemize}
\item[-]Sémantique: Réveille tous les threads en sommeil dans le file d'attente associée à la variable
  condition condId.
\end{itemize}

\subsubsection{\texttt{void CondDestroy(Cond\_t condId)}}
\begin{itemize}
\item[-]Sémantique: Libère les ressources associées à la variable condition condId. 
\item[-]Pré-Condition: Aucun thread n'est en attente dans la file associée à la variable.
\end{itemize}


void CreateDirectory(char * name);

void ChangeDirectoryPath(char * name);

void ListDirectory(char * name);

int Remove(char * name);

void SendMessage(int addressDesti, int boxTo, int boxFrom, char * data);

void ReceiveMessage(char * data, int box);


\section{Implémentation}

\subsection{Processus et Threads}
Nous modélisons un Processus par un objet \texttt{AddrSpace}.
Les fonctionnalités rendues par un objet \texttt{AddrSpace} dépassent la simple gestion de la mémoire puisque l'on trouve encapsulé au sein de cette classe, dans la version originale de nachos, les méthodes relatives, entre autres, à la restoration et la sauvegarde de l'état de la machine \texttt{MIPS} (valeur des registres).

Partant de ce constat nous avons décidé d'étendre encore la sémantique de l'objet \texttt{addrSpace} en ajoutant la liste de threads actifs dans l'espace d'adressage, ainsi que les informations relatives aux jointures entre thread (join).

Nous parlerons par la suite d'espace d'adressage au sens élargi décrit ci-dessus:
Une entité décrivant à la fois un espace mémoire, l'état de la machine \texttt{MIPS} et les informations relatives aux fils d'exécution actifs, c'est à dire un processus.

Nous donnons à chaque objet \texttt{thread} une référence vers son espace d'adressage.

Remarque: Lors de notre réflèxion sur l'implémentation des processus utilisateur, il nous semblait plus cohérant d'un point de vue sémantique de déléguer à \texttt{addrspace}, les méthodes de gestion de la mémoire
et de créer une classe \texttt{processus} regroupant un espace d'adressage et les informations relatives aux fil d'executions vivant dans cet espace. Malheureusement en faisant ce choix nous nous somme trouvé face à des diffultés dans la re-factorisation du code nachos original et pour un petit gain de cohérence avons introduit une trop grande complexité de mise en oeuvre. Nous avons abandoné ce modèle au profit de celui décrit plus haut.

\subsubsection{Piles des threads}
Afin d'accueillir les piles de nouveaux threads on divise un espace d'adressage \texttt{addrSpace} en blocs de pages, de taille \texttt{NumPagesPerStack}.
Dans chaque espace, une bitmap \texttt{stackBitmap} mémorise l'état courant des emplacement de blocs de pages libres pour les piles. 

\subsubsection{Thread Join}
Au sein d'un processus, un thread peut utiliser la fonction join pour attendre la terminaison d'un autre thread.
On maintient dans chaque \texttt{addressSpace} une structure \texttt{joinMap}.
La Map associe à un \texttt{tid} une liste de Threads.

Lorsqu'un Thread $t1$ fait un \texttt{join} sur un Thread $t2$ on ajoute dans \texttt{joinMap}
l'association $(t2, [t1])$. Cette association signifie que $t2$ est attendu par $t1$.
Le Thread $t1$ se met alors en sommeil et attends $t2$. 
Si $t3$ fait un join sur $t2$ la \texttt{joinMap} est dans l'état $(t2, [t1,t3])$ et $t3$ est mis en sommeil.
Lorsque $t2$ termine son exécution il place $t1$ et $t3$ dans la \texttt{readylist} du scheduler.

On maintient une liste \texttt{threadList} des threads actifs dans un espace d'adressage.
Un thread $t1$ ne peut faire un join que vers un thread $t2$ actif.
Un thread peut être attendu par plusieurs threads distincts.

\subsubsection{Création d'un thread}
Toute création de thread utilisateur s'effectue par l'appel système UserTHreadcreate
depuis un thread en mode utilisateur qui résulte en un passage au niveau noyau
via l'instruction assembleur syscal qui déclenche un mécanisme de gestion d'exceptionimplémenté dans la méthode \texttt{ExceptionHandler} de la classe  \texttt{exception.cc}.

L'appel système UserThreadCreate mène donc à l'appel au niveau noyau de la méthode do_UserThreadCreate(). Dans cette méthode on crée un nouvel objet thread $t$ (thread noyau propulseur), destiné à configurer et brancher la machine MIPS sur l'execution d'une nouvelle fonction au sein de l'espace d'adressage du thread ayant effectué l'appel système UserThreadcreate.

On commence par réccupérer la fonction utilisateur $f$ à executer et ses arguments $arg$ dans les registres 4 et 5 de la machine MIPS.
On appelle ensuite la méthode t->Fork(StartUserthead, (f, arg)).
Dans Fork, on initialise la ``partie noyau'' du thread propulseur $t$ de manière
à ce qu'il execute, lorsqu'il devriendra le thread courant, la methode
StartUserThread(f,arg). On donne à $t$ le même espace d'adressage que le
thread courant (le thread ayant appelé UserThreadcreate). On met à jour
la liste des thread de l'espace d'adressage, on cherche un emplacement
libre dans l'espace d'adressage pour la pile du nouveau thread $t$.
On place ensuite le thread $t$ dans la ready list du scheduler.

Lorsque $t$ sera le thread courant il executera la méthode StartUserThread((f,arg))
qui se chargera de configurer les registres de la machine MIPS pour l'exectution
de la fonction utilisateur f(arg) et lancera la machine avec machine->Run(). 

\subsubsection{Creation d'un processus}


\subsubsection{Terminaison d'un thread et d'un processus}
Les threads d'un processus ont une vie (et une mort) indépendante, sans aucune hiérarchie entre eux.
Un processus se termine en même temps que son dernier fil d'exécution.

L'absence de hiérarchie entre threads à l'intérieur d'un processus et entre processus simplifie
l'implémentation des méthodes \texttt{do\_UserThreadCreate} \texttt{do\_UserThreadexit}.

Une terminaison d'un thread (utilisateur) se fait par l'appel système \texttt{UserThreadFinish} qui appelle \texttt{do\_UserThreadexit}. Le thread courant consulte la \texttt{joinMap}, réveille les thread en attente. Enfin on appelle \texttt{finish} pour libérer les ressources associées au thread:
Mise à jour la stackBitmap, la liste des threads de l'espace d'adressage, on décrémente le compteur des
thread actifs sur le système. Si le thread courant était le dernier thread actif, il éteint la machine par un appel à Halt(). Le thread courant devient alors \texttt{threadTobeDestroyed}.

Au prochain appel de la méthode \texttt{run}, le scheduler vérifie si le thread à détruire était le dernier
thread d'un espace d'adressage et libère les ressources associées à cet espace le cas échéant.

\subsubsection{Terminaison automatique des threads}
Dans \texttt{Start.S} lors de l'appel système \texttt{UserThreadCreate}, on place dans le registre 6 de la machine mips l'adresse de l'instruction \texttt{UserThreadExit}.
Lors de la création du nouveau thread au niveau noyau avec \texttt{do\_UserThreadcreate} on récupère
cette adresse depuis \texttt{r6} et au moment de \texttt{Fork}, avant de brancher la machine \texttt{MIPS} sur
le nouveau thread utilisateur on place cette adresse dans le registre \texttt{RetAddrReg}. Ainsi au moment de terminer son exécution le \texttt{PC} sera branché sur UserThreadExit.

\subsubsection{Memoire virtuelle}
La virtualisation de la mémoire des processus utilisateur est mise en oeuvre par une association entre numéro
de page en mémoire virtuelle et un numéro de page physique. Au moment de la création d'un espace d'adressage, l'allocation des pages physiques est réalisée par la méthode \texttt{GetEmptyframerandom()} de l'objet \texttt{FrameProvider}.
Dans cette méthode on construit, à l'aide de la \texttt{bitmap} de l'objet \texttt{frameprovider} une table temporaire des numéros de cadres de pages libres.
On choisit ensuite aléatoirement un numéro de cadre dans cette table. La construction de cette table est coûteuse en temps d'exécution mais facilite la mise en oeuvre du tirage aléatoire.

\subsection{Synchronisation}
Le système Nachos est executé en tant que simple processus utilisateur, non multi-threadé. Aussi tout se passe comme si nous travaillions sur une architecture monoprocesseur. Cela nous facilite la tâche pour l'implémentation des primitives de synchronisation au niveau noyau. En désactivant les interruptions
on empêche toute tentative de préamption du scheduler. On peut ainsi facilement
implémenter des sections critiques en désactivant les intérruptions à l'entrée de la
section et les réactivant à la sortie. C'est sur ce principe simpliste que s'appuient nos primitives Mutex et Sempahore. Notons que si un thread utilisateur
ayant acquis un vérrou se bloque, le système sera bloqué sans aucun espoir de retour.

\subsection{Réseau}
* Numéro de séquence
* Données/Acquitements
* Acquitements cumulatifs
* 
Nous avons mis en place un protocole de transmition de données fiable (sans perte de d'information), qui s'inspire du mécanisme d'acquitement cumulatif de TCP et de la notion de flux d'octet. 
On distingue deux type de messages, données et acquitements. On se place dans le cadre d'un échange bi-directionnel de données entre deux machines $A$ et $B$.
De chaque côté on considère un flux d'octet. Chaque octet du flux est numéroté. TODO -> numsequence

On suppose que $A$ envoie plusieurs messages $m_1, m_2, m_3, ... $ de données à $B$.
$A$ associe un timer à chaque message de donnée, et déclenche le timer à l'envoi du message.
Afin de garantir que fiabilité du transfert chaque message doit être acquité par $B$ dans le temps imparti par le timer. Le principe d'acquitement cumulatif garantit que si $A$ reçoit un acquitement pour un message $m_n$ alors $B$ a bien reçu les messages dont les numéros de séquence sont inférieur ou égal à $n$.

* Envoi reception Données de tailles variables
Lors de l'envoi d'un message dépassant \texttt{maxMailSize} on découpe le message en plusieurs paquets.

\subsection{Système de Fichier}

* Structures et variables importantes 
** FileOpened 
Lors de la création de l'objet \texttt{filesys} système de fichier on crée un tableau qui mémorise les fichiers ouvert. Ce tableau est utilisé pour garantir l'acces exclusif d'un fichier à un unique thread (sur tout le système). Les index dans le tableau sont utilisés comme descripteurs de fichiers fournis aux processus utilisateurs pour la lecture et l'ecriture dans un fichier.


** Currentdirectory
A l'initialisation du système de fichier, on place lerepertoire courant à la racine du système de fichiers.

* Chemins relatifs
Toutes les méthodes createDirectory, changeDir, Create,... acceptent les chemins relatifs.

** FileHeaders
La gestion des fichiers et repertoires sur le disque s'appuie sur les objets fileHeader qui mémorise,
la taille du fichier en octet, le nombre de scteurs de disques utilisés, et les indices des secteurs de disques.
Le fileHeader est un index pour accéder au contenu réel du fichier.


Un répertoire est vu comme un fichier particulier et possède aussi son file header.
 
* FreeMap

* Is directory
Permet de discerner le type d' une entrée de répertoire (fichier ou repertoire).
Utilisé lors d'un change directory, et d'un remove (si le repertoire est vide ou pas).

\subsection{Autres Structures de données, variables globales du système}
\subsubsection{\texttt{thread/system.cc}}
\texttt{unsigned int threadCounter}: Nb total de thread Crées, sert à l'attribution d'un tid.

\texttt{unsigned int nbThreadActifs}: Nb Total de thread actifs du système, sert à éteindre la machine.

\texttt{unsigned int mutexCounter}: Nb Total de mutex créés, sert à l'initialisation des mutex utilisateur.

\texttt{std::map<int,Lock * > * mutexMap}: Association entre un identifiant de mutex (user) et un objet Lock.

\texttt{unsigned int semCounter}: Nb Total de sémaphore créées, sert à l'initialisation des semaphores utilisateur.

\texttt{std::map<int,Semaphore * > * semMap}: Association entre un identifiant de semaphore (user) et un objet Semaphore.

\texttt{unsigned int condCounter}: Nb Total de variables conditions crées, sert à l'initialisation d'une variable
condition utilisateur.

\texttt{std::map<int,Condition * > * condMap}: Association entre l'identifiant d'une variable condition et
un objet Condition.


\section{Organisation}
Pour les premières étapes nous avons travaillé sur un ordinateur commun.
Cette approche basée sur une communication constante et une implication de tous les membres du groupe
nous a permis d'échanger de manière constructive sur les choix d'implémentation, de s'assurer que
nous avions tous une compréhension et vision homogène du fonctionnement de notre code. Nous
avons adopté un point de vue critique vis à vis du code produit,
n'hésitant pas à discuter en détail des points qui ne nous semblaient pas clairs
avant pendant et après l'écriture de nos fonctions. Nous n'avons éprouvé aucune difficultés de communication
tant sur les aspects techniques que dans nos rapport au travail en général.

\section{Annexe}

\section{Tests}

\subsection{Entrées-Sorties}
\begin{itemize}
\item[-] \texttt{Putchar\_0}: Écriture du caractère \texttt{'a'} sur la sortie standard.
\item[-] \texttt{Putchar\_1}: Écriture du caractère \texttt{'a'} et \texttt{'b'} sur la sortie standard.
\item[-] \texttt{Putchar\_2}: Écriture de multiples caractères sur la sortie standard.
\item[-] \texttt{PutInt\_0}: Écriture de l' entier \texttt{10} sur la sortie standard.
\item[-] \texttt{PutInt\_1}: Écriture de l'entier \texttt{0} et de l'entier \texttt{1} sur la sortie standard.
\item[-] \texttt{GetInt\_0}: Lecture d'un entier depuis l'entrée standard.
\item[-] \texttt{GetInt\_PutInt\_0}:
  Lecture d'un entier depuis l'entrée standard.
  Écriture de cet entier sur la sortie standard.
\item[-] \texttt{GetString\_0}: Lecture d'une chaîne de moins de \texttt{20} caractères depuis l'entrée standard, affichage de cette chaîne sur la sortie standard.
\item[-] \texttt{PutString\_0}: Affichage de la chaîne de caractère \texttt{"ABCDEFGHIJklmnopqrstuvwxyz"}.
\item[-] \texttt{PutString\_1}: Affichage de la chaîne \texttt{"ABCDEFGH"} et \texttt{"ijklmnopqrstuvwxyz"}.
\item[-] \texttt{PutString\_2}:   Affichage d'une chaîne de taille supérieure à la
  constante \texttt{MAX\_STRING\_SIZE(=100)} définie dans \texttt{system.h}.
\end{itemize}

\subsection{UserThreads}
Afin de vérifier le bon fonctionnement des structures de synchronisation des fonctions d'entrée-sorties,
les programmes de tests ont été lancés avec et sans l'option \texttt{-rs} qui permet de rendre aléatoire le comportement de l'ordonnanceur.

\begin{itemize}
\item[-] \texttt{UserThreadcreate\_0}: Lancement de \texttt{N} threads utilisateurs qui affichent chacun un entier passé en paramètre lors de leur
  création.
\item[-] \texttt{Userthreadcreate\_1}: Lancement de deux threads utilisateur. Le premier affiche \texttt{"X"} puis le caractère \texttt{'a'} passé en paramètre.
  Le second afficher \texttt{"Y"} puis le caractère \texttt{'b'} passé en paramètre.
\item[-] \texttt{Userthreadcreate\_2}: Lancement d'un nombre de thread trop important pour l'espace mémoire.
  Le programme affiche l'identifiant des threads crées.
\item[-] \texttt{MultiThreadGetString\_0}: Lance plusieurs threads exécutant la commande \texttt{GetString()}.
\end{itemize}

\subsection{Entrées-Sorties Multithread}
 Avec les tests suivants, on vérifie le bon fonctionnement des structures de synchronisation par l'utilisation
  concurrente de synchconsole.
\begin{itemize}
\item[-] \texttt{MultithreadGetChar\_0}: Création de plusieurs threads exécutant \texttt{GetChar}
  puis \texttt{Putchar}.
  Remarque:
  A l'exécution, lorsqu'un thread s'exécute il se bloque sur l'instruction \texttt{GetChar()} et attends une
  entrée utilisateur. L'utilisateur entre un caractère \texttt{'c'} et \texttt{'$\backslash$n'} pour terminer son entrée.
  Suite à l'appel de \texttt{GetChar()}, le caractère \texttt{'$\backslash$n'} est toujours
  présent dans l'entrée standard. Aussi, le thread suivant exécutant \texttt{GetChar()} récupère et
  affiche \texttt{'$\backslash$n'}.
\item[-] \texttt{MultithreadGetInt\_0}: Création de plusieurs threads exécutant \texttt{GetInt}
  puis \texttt{PutInt} pour afficher l'entier saisi.
\item[-] \texttt{MultithreadGetString\_0}: Création de plusieurs threads exécutant
  \texttt{getString} puis \texttt{PutString}.
\item[-] \texttt{MultithreadPutChar\_0}: Création de plusieurs threads exécutant \texttt{getString}
  puis \texttt{PutString}.
\item[-] \texttt{MultithreadPutString\_0}: Création de plusieurs threads exécutant \texttt{PutString}.
\end{itemize}

\section{Consignes}
Un rapport de 8 à 12 pages maximum dont l'objectif est de nous convaincre d'acheter votre nachos. Ce rapport sera structuré en 5 parties :
une (courte) partie présentant rapidement les fonctionnalités intéressante/importante de votre noyau (ce qui vous démarque de vos concurrents, ce qu'on peut faire avec votre logiciel, ...).

Une partie "spécifications" listant ce qui est disponible pour les programmes utilisateurs.
Il faut mettre ici le genre d'information que vous trouvez dans les pages man.
On doit donc trouver tous les appels systèmes implémentés avec leur prototype, la description des arguments,
la description du fonctionnement (fonctionnalités utilisateurs, pas implémentation) de l'appel système,
de la valeur de retour éventuelle, la signalisation des erreurs, ...
Si vous avez également une bibliothèque utilisateur, vous devez décrire ses fonctions de la même manière que les appels systèmes.

Une partie "tests utilisateurs" décrivant les programmes de test que vous avez réalisés, ce qu'ils montrent, ...

Une partie "implémentation" qui explique les points importants de votre implémentation. C'est donc la seule partie qui parle du détail du code que vous avez écrit. Expliquez vos choix d'implémentation.
une partie plus "scolaire" où vous décrivez l'organisation de votre travail (planning, ...), commentaires constructifs sur le déroulement du projet, ...

Les 3 premières parties s'adressent à un utilisateur de votre système. La 4ième partie s'adresse à un développeur qui voudrait continuer à développer votre système. Si vous avez bien travaillé sur les spécifications comme demandé, ces parties techniques seront faciles à écrire.

\end{document}

